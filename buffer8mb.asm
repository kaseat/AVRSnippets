;Copyright (c) 2016 Олег Петроченко

;Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и 
;сопутствующей документации (в дальнейшем именуемыми «Программное Обеспечение»), безвозмездно 
;использовать Программное Обеспечение без ограничений, включая неограниченное право на 
;использование, копирование, изменение, слияние, публикацию, распространение, сублицензирование 
;и/или продажу копий Программного Обеспечения, а также лицам, которым предоставляется данное 
;Программное Обеспечение, при соблюдении следующих условий:

;Указанное выше уведомление об авторском праве и данные условия должны быть включены во все
;копии или значимые части данного Программного Обеспечения.

;ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО 
;ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ,ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО 
;КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ
;ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, 
;В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ, ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ 
;ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.

;Кроме содержимого в этом уведомлении, имя (имена) вышеуказанных держателей авторских прав не 
;должно быть использовано в рекламе или иным способом, чтобы увеличивать продажу, использование 
;или другие работы в этом Программном обеспечении без предшествующего письменного разрешения.

;#define SAFE
#define MAX_BUFF_SIZE    512
#define WARN_BUFF_SIZE   400
;====================================================================================================
;                                      положить значение в буфер
;====================================================================================================
;   ВХОД:       name - имя буфера, куда хотим положить значение
;               reg - регистр со значением, которое кладём в буфер
;   ВЫХОД:      SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      33 цикла
;   ПОРТИМ:     R16,R17,R24,R25,R26,R27,SREG(T)
;====================================================================================================
;   Если определён "#define SAFE" после любых операций с буфером состояние всех задействованых 
;                 регистров (кроме выходных)  возвращается в исходное состояние
;====================================================================================================
;   ВХОД:       name - имя буфера, куда хотим положить значение
;               reg - регистр со значением, которое кладём в буфер
;   ВЫХОД:      SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      63 цикла
;   ПОРТИМ:     SREG(T)
;====================================================================================================
#ifdef SAFE
    #define QueuePush(name,reg) mov r16, reg rcall Queue##name+0x15-6
#else
    #define QueuePush(name,reg) mov r16, reg rcall Queue##name+0x0B
#endif

;====================================================================================================
;                                        достать значение из буфера
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;   ВЫХОД:      R16 - значение, полученное из буфера
;               SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      36 циклов
;   ПОРТИМ:     R16,R17,R24,R25,R26,R27,SREG(T)
;====================================================================================================
;   Если определён "#define SAFE" после любых операций с буфером состояние всех задействованых 
;                 регистров (кроме выходных)  возвращается в исходное состояние
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;   ВЫХОД:      R16 - значение, полученное из буфера
;               SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      68 циклов
;   ПОРТИМ:     R16,SREG(T)
;====================================================================================================
#ifdef SAFE
	#define QueuePop(name)push r17 ldi r17,2 rcall Queue##name+0x15+0x2A-6 pop r17
#else
    #define QueuePop(name) ldi r17,0x02 rcall  Queue##name+0x0B+0x1A
#endif
;====================================================================================================
;                                посмотреть последнее значение в буфере
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;   ВЫХОД:      R16 - значение, полученное из буфера
;               SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      37 циклов
;   ПОРТИМ:     R16,R17,R24,R25,R26,R27,SREG(T)
;====================================================================================================
;   Если определён "#define SAFE" после любых операций с буфером состояние всех задействованых 
;                 регистров (кроме выходных)  возвращается в исходное состояние
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;   ВЫХОД:      R16 - значение, полученное из буфера
;               SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      67 циклов
;   ПОРТИМ:     R16,SREG(T)
;====================================================================================================
#ifdef SAFE
	#define QueuePick(name)push r17 ldi r17, 1 rcall Queue##name+0x15+0x2A-6 pop r17
#else
    #define QueuePick(name) ldi r17, 0x01 rcall Queue##name+0x0B+0x1A
#endif

;====================================================================================================
;                                        инициализация буфера
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;               vol - объем буфера
;   ВЫХОД:      выделение памяти под буфер
;   ВРЕМЯ:      12 циклов
;   ПОРТИМ:     R26,R27
;====================================================================================================
;   Если определён "#define SAFE" после любых операций с буфером состояние всех задействованых 
;                 регистров (кроме выходных)  возвращается в исходное состояние
;====================================================================================================
;   ВХОД:       name - имя буфера, откуда хотим достать значение
;   ВЫХОД:      R16 - значение, полученное из буфера
;               SREG(T) 0 - успех, 1 - буфер заполнен
;   ВРЕМЯ:      20 циклов
;   ПОРТИМ:     R16,SREG(T)
;====================================================================================================
#define QueueInit(name,vol) .equ name##Len = vol\
.dseg Q##name##RAM: .byte vol \
QW##name##RAM: .byte 2 \
QR##name##RAM: .byte 2 \
.cseg Queue##name: q_preinit vol, name

.macro q_preinit
    .if MAX_BUFF_SIZE<@0
        .error "Buffer size must be less than 1000 byte"
    .elif WARN_BUFF_SIZE<@0
        .warning "Buffer is too large! be careful"
    .endif
#ifdef SAFE
	push    XL
	push    XH
#endif
    ldi     XL, low(Q@1RAM)   ; загружаем указатель на 
    ldi     XH, high(Q@1RAM)  ; начало буфера
    sts     QW@1RAM, XL       ; сохраняем указатель записи
    sts     QW@1RAM+1, XH
    sts     QR@1RAM, XL       ; сохраняем указатель чтения
    sts     QR@1RAM+1, XH
#ifdef SAFE
    pop     XH
    pop     XL
    rjmp    PC+0x2B+0x2C
#else
    rjmp    PC+0x1B+0x1D
#endif
    q_init @1
.endmacro

.macro q_init
        set
#ifdef SAFE
        push    r16
        push    r17
        in      r17, SREG
        push    r17
        push    XL
        push    XH
        push    r24
        push    r25
#endif
        lds     XL, QW@0RAM                 ; загружаем указатель записи
        lds     XH, QW@0RAM+1
        ldi     r24, low(Q@0RAM+@0Len)      ; загружаем конец блока памяти
        ldi     r25, high(Q@0RAM+@0Len)
        st      X+, r16                     ; увеличиваем указатель записи
        cp      r24, XL
        cpc     r25, XH                     ; дошли до границы буфера?
        brne    PC+3
        ldi     XL, low(Q@0RAM)             ; да! сбрасываем указатель
        ldi     XH, high(Q@0RAM)
        lds     r24, QR@0RAM                ; нет! загружаем указатель чтения
        lds     r25, QR@0RAM+1
        sts     QW@0RAM, XL                 ; сохраняем указатель записи
        sts     QW@0RAM+1, XH
        cp      XL, r24                     ; дошли до указателя чтения?
        cpc     XH, r25
#ifdef SAFE
        pop    r25
        pop    r24
        pop     XH
        pop     XL
        pop     r17
        breq    PC+2
        cbr     r17, 0x40                   ; да! ставим флаг переполнения
        out     SREG, r17
        pop     r17
		pop     r16
#else
        breq    PC+2
        clt                                 ; да! ставим флаг переполнения
#endif
        ret                                 ; нет! выходим

        set
#ifdef SAFE
        push    r18
        in      r18, SREG
        push    r18
        push    XL
        push    XH
        push    r24
        push    r25
#endif
        lds     XL, QR@0RAM                 ; загружаем указатель чтения
        lds     XH, QR@0RAM+1
        lds     r24, QW@0RAM                ; загружаем указатель записи
        lds     r25, QW@0RAM+1
        cp      r24, XL                     ; дошли до указателя записи?
        cpc     r25, XH
#ifdef SAFE
        breq    PC+0x10                     ; да! чтитать нечего, выходим
#else
        breq    PC+0x11                     ; да! чтитать нечего, выходим
#endif
        ld      r16, X+                     ; нет! начинаем чтение
        ldi     r24, low(Q@0RAM+@0Len)      ; загружаем конец блока памяти
        ldi     r25, high(Q@0RAM+@0Len)
        cp      r24, XL                     ; дошли до границы буфера?
        cpc     r25, XH
        brne    PC+3
        ldi     XL, low(Q@0RAM)             ; да! сбрасываем указатель
        ldi     XH, high(Q@0RAM)
		cpi     r17, 0x01
		brne    PC+2
		sbiw    X,1
        sts     QR@0RAM, XL                 ; сохраняем указатель чтения
        sts     QR@0RAM+1, XH
#ifdef SAFE
        pop     r25
        pop     r24
        pop     XH
        pop     XL
        pop     r18
        breq    PC+2
        cbr     r18, 0x40                   ; да! ставим флаг переполнения
        out     SREG, r18
        pop     r18
		ret
#else
        clt                                 ; нет! ставим флаг успешного чтения
        ret                                 ; и выходим
#endif
.endmacro