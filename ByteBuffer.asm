;Copyright (c) 2016 Олег Петроченко

;Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и 
;сопутствующей документации (в дальнейшем именуемыми «Программное Обеспечение»), безвозмездно 
;использовать Программное Обеспечение без ограничений, включая неограниченное право на 
;использование, копирование, изменение, слияние, публикацию, распространение, сублицензирование 
;и/или продажу копий Программного Обеспечения, а также лицам, которым предоставляется данное 
;Программное Обеспечение, при соблюдении следующих условий:

;Указанное выше уведомление об авторском праве и данные условия должны быть включены во все
;копии или значимые части данного Программного Обеспечения.

;ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО 
;ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ,ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО 
;КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ
;ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, 
;В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ, ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ 
;ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.

;Кроме содержимого в этом уведомлении, имя (имена) вышеуказанных держателей авторских прав не 
;должно быть использовано в рекламе или иным способом, чтобы увеличивать продажу, использование 
;или другие работы в этом Программном обеспечении без предшествующего письменного разрешения.

;===================================================================================================
;                                           Общие положения
;===================================================================================================
; Перед началом работы с буфером его необходимо проинициализировать!!
; Буферов может быть использовано несколько. Один буфер в месте его инициализации занимает в памяти
; программ 120 байт (188 байт с возможностью записи в него строки) и объем vol + 2 байта в SRAM.
; Максимальный объем буфера - 256 байт. Присутствует возможность записывать в буфер строку из кода.
; Для активации данной возможности необходимо объявить директиву препроцессора BYTE_BUFFER_STR.
;===================================================================================================
;                                               API
;===================================================================================================
;    name - имя буфера
;    dReg - регистр обмена (туда приходят и оттуда забираются значения из буфера)
;    vol - вместимость буфера
;    val - константа
;    str - строка для записи в буфер
;===================================================================================================
; InitBuffer(name, dReg, vol) - инициализация буфера
; PushBuffer(name) - протолкнуть в буфер значение из dReg
; PushiBuffer(name,val) - протолкнуть в буфер константу
; PopBuffer(name) - забрать в dReg значение из буфера
; ClrBuffer(name) - очистить буфер
; PushStringToBuffer(name,str) - протолкнуть в буфер строку str
;===================================================================================================
.cseg
#define BYTE_BUFFER_STR                       ; включить работу буфера со строками (+68 байт)


#ifndef BYTE_BUFFER
    #define BYTE_BUFFER
    #define CBBV 8                            ; длина куска кода инициализации буфера
    #define WBBV 22                           ; длина куска кода 
    #define RBBV 22                           ; длина куска кода
    #ifdef BYTE_BUFFER_STR
        #define WSBBV 34                      ; длина куска кода записи строки
        #define BYTE_BUFFER_STR_MAX_LEN 50    ; максимальная длина строки
    #endif
#endif
;===================================================================================================
;                                         Инициализация буфера
;===================================================================================================
;    name - имя буфера
;    dReg - регистр обмена (туда приходят и оттуда забираются значения из буфера)
;    vol - вместимость буфера
;
;     ВНИМАНИЕ: ИСПОЛЬЗОВАТЬ R16 В КАЧЕСТВЕ РЕГИСТРА dReg НЕЛЬЗЯ
;===================================================================================================
;    ВРЕМЯ:     18 циклов
;    РАЗМЕР:    8*2=16 байт
;===================================================================================================
#ifdef BYTE_BUFFER_STR
    #define InitBuffer(name, dReg, vol) \
    .equ BB_##name##_L = vol \
    .def BB_##name##_DR = dReg \
    .dseg BB_##name##_D: .byte vol \
    BB_##name##_W: .byte 1 \
    BB_##name##_R: .byte 1 \
    .cseg rjmp PC+CBBV+WBBV+RBBV+WSBBV+1 \
    BB##name: INIT_BYTE_BUFFER vol, name, dReg
#else
    #define InitBuffer(name, dReg, vol) \
    .equ BB_##name##_L = vol \
    .def BB_##name##_DR = dReg \
    .dseg BB_##name##_D: .byte vol \
    BB_##name##_W: .byte 1 \
    BB_##name##_R: .byte 1 \
    .cseg rjmp PC+CBBV+WBBV+RBBV+1 \
    BB##name: INIT_BYTE_BUFFER vol, name, dReg
#endif

;===================================================================================================
;                            Добавление значения из DATA в буфер
;===================================================================================================
;    ВРЕМЯ:     31 цикл
;===================================================================================================
#define PushBuffer(name) rcall BB##name+CBBV

;===================================================================================================
;                               Добавление константы в буфер
;===================================================================================================
;    ВРЕМЯ:     32 цикла
;===================================================================================================
#define PushiBuffer(name,val) ldi BB_##name##_DR,val  rcall BB##name+CBBV

;===================================================================================================
;                              Чтение значения в DATA из буфера
;===================================================================================================
;    ВРЕМЯ:     27 циклов
;===================================================================================================
#define PopBuffer(name) rcall BB##name+CBBV+WBBV

;===================================================================================================
;                                         Очистка буфера
;===================================================================================================
;    ВРЕМЯ:     16 циклов
;===================================================================================================
#define ClrBuffer(name) rcall BB##name

;===================================================================================================
;                                 Добавление строки в буфер
;===================================================================================================
;    ВРЕМЯ:     зависит от длины строки
;===================================================================================================
#ifdef BYTE_BUFFER_STR
    #define PushStringToBuffer(name,str) STRING_BYTE_BUFFER str,name
#endif

;===================================================================================================
;                                   Инициализация буфера
;===================================================================================================
;    ВРЕМЯ:     18 циклов
;    РАЗМЕР:    1*2=2 байта
;===================================================================================================
.macro INIT_BYTE_BUFFER
    .if @0>256
	    .error "Max buffer size is 256 byte!"
    .endif
    CLEAR_BYTE_BUFFER @1
    WRITE_BYTE_BUFFER @1
    READ_BYTE_BUFFER @1
    #ifdef BYTE_BUFFER_STR
        PUSH_STRING_BYTE_BUFFER @1
    #endif
    rcall BB@1
.endmacro

;===================================================================================================
;                                          Очистка буфера
;===================================================================================================
;    ВРЕМЯ:     18 циклов
;    РАЗМЕР:    8*2=16 байт
;===================================================================================================

.macro CLEAR_BYTE_BUFFER
	push r16
	ldi r16,0x00
	sts BB_@0_R, r16
	sts BB_@0_W, r16
	pop r16
	ret
.endm

;===================================================================================================
;                                          Запись в буфер
;===================================================================================================
;    ВХОД:       ргистр обмена, определённый в InitBuffer()
;    ВЫХОД:      SREG(T) 0 - успех, 1 - буфер заполнен
;    ВРЕМЯ:      31 цикл
;    РАЗМЕР:     22*2 = 44 байт
;    ПОРТИМ:     R26,R27,SREG
;===================================================================================================

.macro WRITE_BYTE_BUFFER
        set
        push    r16
        lds     XL, BB_@0_W             ; грузим указатель на ячейку записи
        mov     r16, XL                 ; сохраняем его
        clr     XH
        subi    XL, low(-BB_@0_D)
        sbci    XH, high(-BB_@0_D)
        st      X, BB_@0_DR             ; выгружаем из ргистра обмена в SRAM
        inc     r16                     ; увеличиваем указатель записи
        cpi     r16, BB_@0_L            ; дошли до границы буфера?
        brne    PC+2
        clr     r16                     ; да! очищаем указатель записи
		lds     XL, BB_@0_R             ; нет! грузим указатель на ячейку чтения
		sts     BB_@0_W, r16            ; сохраняем указатель записи
        cp      XL, r16                 ; дошли до указателя чтения?
        breq    PC+2
        clt                             ; да! ставим флаг переполнения
        pop     r16
        ret                             ; нет! выходим
.endm

;===================================================================================================
;                                        Чтение из буфера
;===================================================================================================
;	ВХОД:		N/A
;	ВЫХОД:		r16, SREG(T) 0 - успех, 1 - буфер пуст
;	ВРЕМЯ:		31 цикл если буфер не пуст
;				15 циклов если буфер пуст
;	РАЗМЕР:		22*2 = 44 байт
;===================================================================================================
.macro READ_BYTE_BUFFER
        set
		lds     XL, BB_@0_R             ; грузим указатель на ячейку чтения
        lds     XH, BB_@0_W             ; грузим указатель на ячейку записи
        cp      XL, XH                  ; дошли до указателя записи?
		breq    RE@0                    ; да! читать нечего, выходим
		push    r16
        mov     r16, XL                 ; сохраняем его
        clr     XH                      ; нет! грузим начало буфера
        subi    XL, low(-BB_@0_D)
        sbci    XH, high(-BB_@0_D)
        ld      BB_@0_DR, X             ; загружаем в ргистр обмена SRAM
        inc     r16                     ; увеличиваем указатель чтения
        cpi     r16, BB_@0_L            ; дошли до границы буфера?
        brne    PC+2
        clr     r16                     ; да! очищаем указатель чтения
        sts     BB_@0_R, r16            ; нет! сохраняем указатель чтения
        clt								; ставим флаг успешного чтения
        pop     r16
RE@0:   ret                             ; и выходим
.endm

;===================================================================================================
;                                 Запись строки в буфер (одна на буфер)
;===================================================================================================
;	ВХОД:		ZH, XL - указатель на начало строки
;               r17 - длина строки
;               @0 - имя буфера
;	ВЫХОД:		SREG(T) 0 - успех, 1 - запись не прошла
;	ВРЕМЯ:		зависит от длины строки
;	РАЗМЕР:		30*2 = 60 байт
;===================================================================================================
#ifdef BYTE_BUFFER_STR
.macro PUSH_STRING_BYTE_BUFFER
pps@0:  set
        push    r16
        push    r18
        lds     XH, BB_@0_R              ; грузим указатель на ячейку чтения
        lds     XL, BB_@0_W              ; грузим указатель на ячейку записи
        mov     r16,XL
        sub     XH, XL                   ; считаем свободное место в буфере
        brpl    PC+2                     ; r-w
        subi    XH, -BB_@0_L             ; l+r-w
        breq    PC-1
        cp      XH, r17                  ; и сравниваем с длиной добавляемой строки
        brpl    PC+2
        rjmp    erws@0
        clr     XH                       ; загружаем указатель на ячейку записи
        subi    XL, low(-BB_@0_D)
        sbci    XH, high(-BB_@0_D)
stt@0:  lpm     r18, Z+
        st      X+, r18                  ; выгружаем из ргистра обмена в SRAM
        inc     r16                      ; увеличиваем указатель записи
        cpi     r16, BB_@0_L             ; дошли до границы буфера?
        brne    PC+4
        clr     r16                      ; да! очищаем указатель записи
        subi    XL, BB_@0_L
        sbc     XH, r16
        dec     r17
        brne    stt@0
		sts     BB_@0_W, r16
        clt
erws@0: pop     r18
        pop     r16
        ret
.endm

;===================================================================================================
;                             Запись строки в буфер (одна на вызов)
;===================================================================================================
;	ВХОД:       @0 - входная строка
;               @1 - имя буфера
;	ВЫХОД:		SREG(T) 0 - успех, 1 - запись не прошла
;	ВРЕМЯ:		зависит от длины строки
;	РАЗМЕР:		зависит от длины строки + 14 байт
;===================================================================================================
.macro STRING_BYTE_BUFFER
    .if STRLEN(@0)>BYTE_BUFFER_STR_MAX_LEN
        .error "Strng's too long"
    .endif

    ldi    ZL, low((PC+5)*2)        ; грузим указатель на начало строки
    ldi    ZH, high((PC+4)*2)
    push    r17                     ; кидаем в стэк временный регистр
    ldi     r17, STRLEN(@0)
    .if STRLEN(@0)%2==0
        rjmp PC+(STRLEN(@0)/2)+2    ; переход к концу строки в памяти
        .db @0,0x00,0x00            ; запись строки в память программ
    .else
        rjmp PC+(STRLEN(@0)/2)+2    ; переход к концу строки в памяти
        .db @0,0x00                 ; запись строки в память программ
    .endif
    rcall BB@1+CBBV+WBBV+RBBV       ; вызываем подпрограмму записи в буфер
    pop     r17                     ; восстанавливаем временный регистр
.endm
#endif

