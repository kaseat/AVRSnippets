;Copyright (c) 2016 Олег Петроченко

;Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и 
;сопутствующей документации (в дальнейшем именуемыми «Программное Обеспечение»), безвозмездно 
;использовать Программное Обеспечение без ограничений, включая неограниченное право на 
;использование, копирование, изменение, слияние, публикацию, распространение, сублицензирование 
;и/или продажу копий Программного Обеспечения, а также лицам, которым предоставляется данное 
;Программное Обеспечение, при соблюдении следующих условий:

;Указанное выше уведомление об авторском праве и данные условия должны быть включены во все
;копии или значимые части данного Программного Обеспечения.

;ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО 
;ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ,ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО 
;КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ
;ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, 
;В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ, ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ 
;ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.

;Кроме содержимого в этом уведомлении, имя (имена) вышеуказанных держателей авторских прав не 
;должно быть использовано в рекламе или иным способом, чтобы увеличивать продажу, использование 
;или другие работы в этом Программном обеспечении без предшествующего письменного разрешения.

#ifndef BYTE_BUFFER
    #define BYTE_BUFFER
    #define CBBV 8
    #define WBBV 22
    #define RBBV 22
#endif

;==========================================================================
;                        Инициализация буфера
;==========================================================================
;     ВНИМАНИЕ: ИСПОЛЬЗОВАТЬ R16 В КАЧЕСТВЕ РЕГИСТРА dReg НЕЛЬЗЯ
;==========================================================================
;    ВХОД:      name - имя буфера
;               dReg - регистр обмена с буфером
;               vol - размер буфера
;    ВРЕМЯ:     18 циклов
;    РАЗМЕР:    8*2=16 байт
;==========================================================================
#define InitBuffer(name, dReg, vol) \
.equ BB_##name##_L = vol \
.def BB_##name##_DR = dReg \
.dseg BB_##name##_D: .byte vol \
BB_##name##_W: .byte 1 \
BB_##name##_R: .byte 1 \
.cseg rjmp PC+CBBV+WBBV+RBBV+1 \
BB##name: INIT_BYTE_BUFFER vol, name, dReg

;==========================================================================
;                    Добавление значения из DATA в буфер
;==========================================================================
;    ВХОД:      name - имя буфера
;    ВРЕМЯ:     31 цикл
;==========================================================================
#define PushBuffer(name) rcall BB##name+CBBV

;==========================================================================
;                      Добавление константы в буфер
;==========================================================================
;    ВХОД:      name - имя буфера
;               val - константа
;    ВРЕМЯ:     32 цикла
;==========================================================================
#define PushiBuffer(name,val) ldi BB_##name##_DR,val  rcall BB##name+CBBV

;==========================================================================
;                   Чтение значения в DATA из буфера
;==========================================================================
;    ВХОД:      name - имя буфера
;    ВРЕМЯ:     27 циклов
;==========================================================================
#define PopBuffer(name) rcall BB##name+CBBV+WBBV

;==========================================================================
;                             Очистка буфера
;==========================================================================
;    ВХОД:      name - имя буфера
;    ВРЕМЯ:     16 циклов
;==========================================================================
#define ClrBuffer(name) rcall BB##name

;==========================================================================
;                        Инициализация буфера
;==========================================================================
.macro INIT_BYTE_BUFFER
    .if @0>256
	    .error "Max buffer size is 256 byte!"
    .endif
    CLEAR_BYTE_BUFFER @1
    WRITE_BYTE_BUFFER @1
    READ_BYTE_BUFFER @1
    rcall BB@1
.endmacro

;==========================================================================
;                            Очистка буфера
;==========================================================================
;    ВРЕМЯ:     18 циклов
;    РАЗМЕР:    8*2=16 байт
;==========================================================================

.macro CLEAR_BYTE_BUFFER
	push r16
	ldi r16,0x00
	sts BB_@0_R, r16
	sts BB_@0_W, r16
	pop r16
	ret
.endm

;==========================================================================
;                             Запись в буфер
;==========================================================================
;    ВХОД:       ргистр обмена, определённый в InitBuffer()
;    ВЫХОД:      SREG(T) 0 - успех, 1 - буфер заполнен
;    ВРЕМЯ:      31 цикл
;    РАЗМЕР:     22*2 = 44 байт
;    ПОРТИМ:     R26,R27,SREG
;==========================================================================

.macro WRITE_BYTE_BUFFER
        set
        push    r16
        lds     XL, BB_@0_W             ; грузим указатель на ячейку записи
        mov     r16, XL                 ; сохраняем его
        clr     XH
        subi    XL, low(-BB_@0_D)
        sbci    XH, high(-BB_@0_D)
        st      X, BB_@0_DR             ; выгружаем из ргистра обмена в SRAM
        inc     r16                     ; увеличиваем указатель записи
        cpi     r16, BB_@0_L            ; дошли до границы буфера?
        brne    PC+2
        clr     r16                     ; да! очищаем указатель записи
		lds     XL, BB_@0_R             ; нет! грузим указатель на ячейку чтения
		sts     BB_@0_W, r16            ; сохраняем указатель записи
        cp      XL, r16                 ; дошли до указателя чтения?
        breq    PC+2
        clt                             ; да! ставим флаг переполнения
        pop     r16
        ret                             ; нет! выходим
.endm

;==========================================================================
;							Чтение из буфера
;==========================================================================
;	ВХОД:		N/A
;	ВЫХОД:		r16, SREG(T) 0 - успех, 1 - буфер пуст
;	ВРЕМЯ:		31 цикл если буфер не пуст
;				15 циклов если буфер пуст
;	РАЗМЕР:		22*2 = 44 байт
;==========================================================================
.macro READ_BYTE_BUFFER
        set
		lds     XL, BB_@0_R             ; грузим указатель на ячейку чтения
        lds     XH, BB_@0_W             ; грузим указатель на ячейку записи
        cp      XL, XH                  ; дошли до указателя записи?
		breq    RE@0                    ; да! читать нечего, выходим
		push    r16
        mov     r16, XL                 ; сохраняем его
        clr     XH                      ; нет! грузим начало буфера
        subi    XL, low(-BB_@0_D)
        sbci    XH, high(-BB_@0_D)
        ld      BB_@0_DR, X             ; загружаем в ргистр обмена SRAM
        inc     r16                     ; увеличиваем указатель чтения
        cpi     r16, BB_@0_L            ; дошли до границы буфера?
        brne    PC+2
        clr     r16                     ; да! очищаем указатель чтения
        sts     BB_@0_R, r16            ; нет! сохраняем указатель чтения
        clt								; ставим флаг успешного чтения
        pop     r16
RE@0:   ret                             ; и выходим
.endm
